Nice, now weâ€™re talking full-scenario mode.
Iâ€™ll walk you through **Scenario A** exactly like youâ€™d do it in the exam: clean sequence, no fluff, with verification at each stage.

Iâ€™ll assume:

* Disk: `/dev/sdb`
* VG name: `vgproj`
* LV name: `lvproj`
* Mountpoint: `/projdata`
* Users: `user1`, `user2` (weâ€™ll create them if needed)
* Filesystem: `XFS` (typical for RHCSA)

You can swap names/sizes to whatever the task specifies in your real exam.

---

## 0. Prep: make sure users exist

```bash
id user1 2>/dev/null || useradd user1
id user2 2>/dev/null || useradd user2
```

---

## 1. Create an LVM volume

### 1.1 Create PV on `/dev/sdb`

```bash
pvcreate /dev/sdb
```

**Verify:**

```bash
pvs
pvdisplay /dev/sdb
```

---

### 1.2 Create VG `vgproj`

```bash
vgcreate vgproj /dev/sdb
```

**Verify:**

```bash
vgs
vgdisplay vgproj
```

---

### 1.3 Create LV `lvproj` (example: 5G)

```bash
lvcreate -L 5G -n lvproj vgproj
```

**Verify:**

```bash
lvs
lvdisplay /dev/vgproj/lvproj
```

---

## 2. Create a filesystem on it (XFS)

```bash
mkfs.xfs /dev/vgproj/lvproj
```

**Verify:**

```bash
blkid /dev/vgproj/lvproj
```

You should see `TYPE="xfs"`.

---

## 3. Mount it persistently

### 3.1 Create mountpoint

```bash
mkdir -p /projdata
```

### 3.2 Get the UUID

```bash
blkid /dev/vgproj/lvproj
```

Example output:

```text
/dev/vgproj/lvproj: UUID="abcd-1234-efgh-5678" TYPE="xfs"
```

### 3.3 Add to `/etc/fstab`

Edit the file:

```bash
vi /etc/fstab
```

Add a line (use your actual UUID):

```text
UUID=abcd-1234-efgh-5678   /projdata   xfs   defaults   0 0
```

### 3.4 Mount everything

```bash
mount -a
```

**Verify:**

```bash
df -h /projdata
```

You should see `/dev/mapper/vgproj-lvproj` (or similar) mounted on `/projdata`.

---

## 4. Set ACLs

Goal:

* `user1` â†’ full access (rwx)
* `user2` â†’ read-only (r-x)

### 4.1 Make base permissions sane

```bash
chmod 770 /projdata
```

This keeps it locked to owner/group + ACL users.

### 4.2 Apply ACLs

```bash
setfacl -m u:user1:rwx /projdata
setfacl -m u:user2:rx  /projdata
```

Optionally, make them default for new files:

```bash
setfacl -m d:u:user1:rwx /projdata
setfacl -m d:u:user2:rx  /projdata
```

**Verify:**

```bash
getfacl /projdata
```

You should see entries like:

```text
user:user1:rwx
user:user2:r-x
default:user:user1:rwx
default:user:user2:r-x
```

Quick functional check:

```bash
sudo -u user1 touch /projdata/u1file
sudo -u user2 touch /projdata/u2file   # this should FAIL (no write)
sudo -u user2 ls /projdata             # should work (read/execute)
```

---

## 5. Ensure SELinux permits access

If this is just normal user access on a local filesystem, usually the default context is fine. The key exam action is to **ensure labeling is correct**.

### 5.1 Make sure SELinux is enforcing (as required)

```bash
getenforce
```

If they want enforcing and itâ€™s not:

```bash
setenforce 1
```

*(Persisting via `/etc/selinux/config` is usually not required for RHCSA unless explicitly asked.)*

### 5.2 Restore default SELinux context on the mountpoint

```bash
restorecon -Rv /projdata
```

**Verify:**

```bash
ls -Zd /projdata
```

You should see a normal directory type like `default_t` or similar for user data, not something obviously wrong or custom.

If the scenario instead had some *service* accessing `/projdata` (for example Apache, NFS, etc.), then youâ€™d adjust the SELinux type (e.g. `httpd_sys_content_t`). But since your scenario only mentions â€œensure SELinux permits accessâ€, **restoring correct labels and keeping SELinux in Enforcing** is the expected exam solution.

---

## Quick Summary Flow (what youâ€™d do under time pressure)

```bash
pvcreate /dev/sdb
vgcreate vgproj /dev/sdb
lvcreate -L 5G -n lvproj vgproj
mkfs.xfs /dev/vgproj/lvproj
mkdir /projdata
blkid /dev/vgproj/lvproj   # copy UUID
vi /etc/fstab              # add UUID line
mount -a

id user1 || useradd user1
id user2 || useradd user2
chmod 770 /projdata
setfacl -m u:user1:rwx /projdata
setfacl -m u:user2:rx  /projdata
setfacl -m d:u:user1:rwx /projdata
setfacl -m d:u:user2:rx  /projdata

restorecon -Rv /projdata
getenforce
```
Here is **Scenario B** solved exactly the way you should do it on the RHCSA exam â€” clean, fast, and with correct verification steps.
This combines networking, httpd service management, firewalld, and SELinux context changes.

Iâ€™ll assume:

* Interface: **ens33**
* Static IP: **192.168.20.50/24**
* Gateway: **192.168.20.1**
* DNS: **8.8.8.8**
* Custom Apache document root: **/webapp**

You can substitute values to match the exam scenario.

---

# ðŸ”¥ **Scenario B â€” Full RHCSA-Style Solution**

---

# **1) Configure a static network profile**

Create a static profile named `static-net`:

```bash
nmcli con add con-name static-net ifname ens33 type ethernet ipv4.method manual \
ipv4.addresses 192.168.20.50/24 ipv4.gateway 192.168.20.1 ipv4.dns 8.8.8.8
```

Enable autoconnect:

```bash
nmcli con mod static-net connection.autoconnect yes
```

Bring the connection up:

```bash
nmcli con up static-net
```

### **Verify**

```bash
ip a show ens33
ip r
nmcli dev show ens33 | grep DNS
ping -c 3 8.8.8.8
```

---

# **2) Enable an HTTP server**

Install Apache HTTPD (if not installed):

```bash
dnf install -y httpd
```

Enable and start the service:

```bash
systemctl enable --now httpd
```

### **Verify**

```bash
systemctl status httpd
ss -tlnp | grep :80
```

You should see Apache listening on port 80.

---

# **3) Allow HTTP through the firewall**

Add HTTP service:

```bash
firewall-cmd --permanent --add-service=http
firewall-cmd --reload
```

### **Verify**

```bash
firewall-cmd --list-services
```

You should see:

```
http
```

Test via curl:

```bash
curl http://localhost
```

---

# **4) Change SELinux context so Apache can serve files from a custom directory**

### **Goal:** Apache serves files from `/webapp` instead of `/var/www/html`.

---

## **Step 4.1 â€” Create custom directory**

```bash
mkdir -p /webapp
echo "Welcome to WebApp" > /webapp/index.html
```

---

## **Step 4.2 â€” Assign Apache-readable SELinux type**

Apache needs `httpd_sys_content_t` for read-only serving.

```bash
semanage fcontext -a -t httpd_sys_content_t "/webapp(/.*)?"
restorecon -Rv /webapp
```

Verify:

```bash
ls -Zd /webapp
```

Expected type:

```
httpd_sys_content_t
```

---

## **Step 4.3 â€” Update Apache configuration**

Edit the DocumentRoot:

```bash
sed -i 's|DocumentRoot .*|DocumentRoot "/webapp"|' /etc/httpd/conf/httpd.conf

# Also update the <Directory> section if needed:
sed -i 's|<Directory "/var/www/html">|<Directory "/webapp">|' /etc/httpd/conf/httpd.conf
```

Reload Apache:

```bash
systemctl restart httpd
```

---

## **Step 4.4 â€” Test Apache with new directory**

```bash
curl http://localhost
```

Expected output:

```
Welcome to WebApp
```

### **Double-check SELinux is enforcing**

```bash
getenforce
```

Should show:

```
Enforcing
```

---

# âœ… **Scenario B Completed Successfully**

You now have:

âœ” A static network profile
âœ” Apache installed, enabled, and running
âœ” HTTP allowed in the firewall
âœ” SELinux correctly configured to permit Apache to serve a custom directory

---

Here is **Scenario C**, written and solved exactly in RHCSA exam style.
This is one of the *most important* multi-part scenarios because it combines boot recovery, fstab repair, password reset, service troubleshooting, and scripting â€” all high-value exam items.

---

# ðŸ”¥ **Scenario C â€” Full RHCSA-Style Solution**

You must:

1. **Fix a boot failure caused by a typo in `/etc/fstab`**
2. **Reset the root password using GRUB and rd.break**
3. **Fix a misconfigured systemd service**
4. **Create a script that configures users and groups**

This solution shows the exact sequence an examiner expects.

---

# ------------------------------------------------------

# **1) Fix a boot failure caused by a typo in `/etc/fstab`**

### **Symptom:**

System boots into *emergency mode* or *dracut shell* with an error like:

```
Failed to mount /data
```

### **Exam-Style Steps**

### **1.1 Remount root filesystem as read-write:**

```bash
mount -o remount,rw /
```

### **1.2 Edit `/etc/fstab`:**

```bash
vi /etc/fstab
```

Common mistakes to fix:

* Wrong UUID
* Wrong filesystem type
* Misspelled mountpoint
* Missing `0 0` fields
* Trailing whitespace

### **1.3 Test fstab (critical):**

```bash
mount -a
```

If no errors â†’ success.

### **1.4 Reboot:**

```bash
reboot
```

---

# ------------------------------------------------------

# **2) Reset the root password**

### **When the system is at GRUB:**

### **2.1 Interrupt GRUB**

* Highlight the default kernel
* Press **e**

### **2.2 Add `rd.break` to the Linux line**

Find the line starting with:

```
linux /vmlinuz
```

Append to the end:

```
rd.break
```

### **2.3 Boot**

Press **Ctrl+X** or **F10**

---

### **2.4 Remount sysroot read/write**

```bash
mount -o remount,rw /sysroot
```

### **2.5 Switch to actual root filesystem**

```bash
chroot /sysroot
```

### **2.6 Change root password**

```bash
passwd root
```

### **2.7 Ensure SELinux relabel (mandatory)**

```bash
touch /.autorelabel
```

### **2.8 Exit twice**

```bash
exit
exit
```

System reboots, relabels, and root login now works.

---

# ------------------------------------------------------

# **3) Fix a misconfigured service**

Letâ€™s assume the broken service is named **demoapp.service**.
Typical exam symptoms:

```
demoapp.service: Failed with result 'exit-code'
demoapp.service: Unit is masked
Missing ExecStart
Wrong file permissions
```

---

### **3.1 Check service status**

```bash
systemctl status demoapp
```

### **3.2 Inspect detailed logs**

```bash
journalctl -u demoapp -xe
```

### **3.3 Common fixes**

#### **A. Service is masked**

```bash
systemctl unmask demoapp
```

#### **B. Wrong or missing ExecStart**

Edit service file:

```bash
vi /etc/systemd/system/demoapp.service
```

Ensure lines like:

```
[Service]
ExecStart=/usr/bin/demoapp
```

Then reload systemd:

```bash
systemctl daemon-reload
```

#### **C. Permissions incorrect**

```bash
chmod +x /usr/bin/demoapp
```

#### **D. Enable and start**

```bash
systemctl enable --now demoapp
```

### **Verify**

```bash
systemctl status demoapp
```

---

# ------------------------------------------------------

# **4) Create a script that configures users and groups**

### **Goal:**

Write a script `/root/config_users.sh` that:

* Creates group `engineering`
* Creates users `alice`, `bob`, `carol`
* Adds them to group `engineering`
* Logs every action to `/var/log/userconfig.log`

---

### **4.1 Create script**

```bash
vi /root/config_users.sh
```

Paste:

```bash
#!/bin/bash

LOG="/var/log/userconfig.log"
GROUP="engineering"

# Create group if missing
if ! getent group $GROUP >/dev/null; then
    groupadd $GROUP
    echo "$(date): Created group $GROUP" >> $LOG
fi

# Users to create
USERS="alice bob carol"

for u in $USERS; do
    if id $u &>/dev/null; then
        echo "$(date): User $u already exists" >> $LOG
    else
        useradd -G $GROUP $u
        echo "$(date): Created user $u and added to $GROUP" >> $LOG
    fi
done
```

---

### **4.2 Make script executable**

```bash
chmod +x /root/config_users.sh
```

### **4.3 Run script**

```bash
/root/config_users.sh
```

---

### **4.4 Verify**

```bash
getent group engineering
id alice
id bob
id carol
cat /var/log/userconfig.log
```

Everything should reflect the actions performed.

---

# ------------------------------------------------------

# ðŸŽ¯ **Scenario C Completed Successfully**

You now have:

âœ” A repaired boot sequence
âœ” A new root password
âœ” A fixed systemd service
âœ” A user/group automation script

This is exactly the level of combined-task mastery the RHCSA exam expects.

---

Perfect â€” here are **three advanced multi-domain RHCSA scenarios**, each combining several high-value exam topics into realistic, exam-style challenges.
These are meant to push you into full-workflow thinking: networking + services + SELinux, full LVM stack + boot rescue + swap, and Apache + autofs + ACL + SELinux.

Iâ€™ll present each scenario **first**, then provide the **clean, exam-grade solution** immediately after.

---

# ðŸ”¥ **Scenario 1: SELinux + Firewalld + systemd + Networking**

*(High-value RHCSA multi-topic integration)*

Your team is deploying an internal monitoring service called **monitorapp**. You must configure networking, systemd behavior, firewall access, and SELinux so the service works properly.

---

# **ðŸ”· Requirements**

### **A. Network**

* Configure interface `ens33` with a **static IP**:
  `192.168.100.50/24`
  Gateway: `192.168.100.1`
  DNS: `1.1.1.1`
* The profile must **autoconnect** at boot.

---

### **B. systemd Service**

A custom service called `/usr/local/bin/monitorapp.sh` must run at boot.

You must:

1. Create the service file:
   `/etc/systemd/system/monitorapp.service`
2. ExecStart should run `/usr/local/bin/monitorapp.sh`
3. The service must run **continuously** and restart if it crashes
4. Enable it at boot

Assume the script is already present but not executable.

---

### **C. Firewalld**

* Allow **port 9090/tcp** permanently
* Block the IP **192.168.100.99**
* Ensure SSH stays accessible

---

### **D. SELinux**

* The service writes logs to `/var/monitorlogs`
* SELinux currently blocks this
* Fix SELinux labels so the service can write to that directory
* SELinux must remain **Enforcing**

---

# **âœ” Scenario 1 â€” Full Exam-Quality Solution**

---

## **A. Networking**

```bash
nmcli con add con-name static100 ifname ens33 type ethernet ipv4.method manual \
ipv4.addresses 192.168.100.50/24 ipv4.gateway 192.168.100.1 ipv4.dns 1.1.1.1

nmcli con mod static100 connection.autoconnect yes
nmcli con up static100
```

Verify:

```bash
ip a s ens33
ip r
nmcli dev show ens33 | grep DNS
```

---

## **B. systemd Service**

Make script executable:

```bash
chmod +x /usr/local/bin/monitorapp.sh
```

Create service:

```bash
cat << EOF > /etc/systemd/system/monitorapp.service
[Unit]
Description=Monitoring Application
After=network.target

[Service]
ExecStart=/usr/local/bin/monitorapp.sh
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF
```

Reload, enable, start:

```bash
systemctl daemon-reload
systemctl enable --now monitorapp
```

Verify:

```bash
systemctl status monitorapp
```

---

## **C. Firewalld**

```bash
firewall-cmd --permanent --add-port=9090/tcp
firewall-cmd --permanent --add-rich-rule='rule family="ipv4" source address="192.168.100.99" drop'
firewall-cmd --permanent --add-service=ssh
firewall-cmd --reload
```

Verify:

```bash
firewall-cmd --list-ports
firewall-cmd --list-rich-rules
```

---

## **D. SELinux Fix**

Create directory:

```bash
mkdir -p /var/monitorlogs
```

Assign write-compatible context:

```bash
semanage fcontext -a -t var_log_t "/var/monitorlogs(/.*)?"
restorecon -Rv /var/monitorlogs
```

Verify:

```bash
ls -Zd /var/monitorlogs
getenforce
```

---

---

# ðŸ”¥ **Scenario 2: Multi-disk LVM + fstab + swap + rescue mode**

This scenario mirrors RHCSA rescue + storage troubleshooting tasks.

---

# **ðŸ”· Requirements**

### **A. Storage**

Using disks `/dev/sdb` and `/dev/sdc`:

1. Create PVs
2. Create VG `datavg`
3. Create LV `datalv` size 8G
4. Format with XFS
5. Mount persistently at `/data`

---

### **B. Extend the LV**

* Add **+4G** to the LV
* Grow XFS online

---

### **C. Swap**

* Create **2G swap file** at `/swapfile`
* Make it persistent

---

### **D. Boot Failure**

System fails to boot due to a bad `/etc/fstab` entry you created earlier.
You must enter **emergency/rescue mode**, fix fstab, and reboot successfully.

---

# âœ” **Scenario 2 â€” Full Exam-Quality Solution**

---

## **A. LVM Build**

```bash
pvcreate /dev/sdb /dev/sdc
vgcreate datavg /dev/sdb /dev/sdc
lvcreate -L 8G -n datalv datavg
mkfs.xfs /dev/datavg/datalv
mkdir /data
```

Grab UUID:

```bash
blkid /dev/datavg/datalv
```

Add to fstab:

```
UUID=<uuid>   /data   xfs   defaults   0 0
```

Mount:

```bash
mount -a
df -h /data
```

---

## **B. Extend LV + XFS**

```bash
lvextend -L +4G /dev/datavg/datalv
xfs_growfs /data
```

Verify:

```bash
df -h /data
```

---

## **C. Swap file**

```bash
dd if=/dev/zero of=/swapfile bs=1M count=2048
chmod 600 /swapfile
mkswap /swapfile
swapon /swapfile
```

Add to fstab:

```
/swapfile  swap  swap  defaults  0 0
```

Verify:

```bash
swapon --show
```

---

## **D. Fix fstab boot failure**

When the system drops to emergency mode:

### Make root FS writable:

```bash
mount -o remount,rw /
```

### Edit fstab:

```bash
vi /etc/fstab
```

Correct or comment out bad entry.

### Validate:

```bash
mount -a
```

Reboot:

```bash
reboot
```

---

---

# ðŸ”¥ **Scenario 3: Apache + autofs + ACL + SELinux Contexts**

This combines three highly testable RHCSA areas.

---

# **ðŸ”· Requirements**

You must:

### **A. Create a custom Apache document root**

* Directory: `/srv/webdata`
* Owner: `apache:apache`
* Create `index.html` with text "Hello RHCSA"

---

### **B. SELinux**

* Set proper SELinux context so Apache can read files
* SELinux must remain Enforcing

---

### **C. ACL**

* `userA` â†’ full access
* `userB` â†’ read-only

---

### **D. autofs**

* Configure autofs so that accessing `/misc/webmount` auto-mounts the directory `/srv/webdata` (local autofs mapping)

---

### **E. Firewall**

* Allow HTTP permanently

---

# âœ” **Scenario 3 â€” Full Exam-Quality Solution**

---

## **A. Apache document root**

```bash
mkdir -p /srv/webdata
echo "Hello RHCSA" > /srv/webdata/index.html
chown -R apache:apache /srv/webdata
```

Update Apache configuration:

```bash
sed -i 's|DocumentRoot.*|DocumentRoot "/srv/webdata"|' /etc/httpd/conf/httpd.conf
sed -i 's|<Directory "/var/www/html">|<Directory "/srv/webdata">|' /etc/httpd/conf/httpd.conf
```

Enable httpd:

```bash
systemctl enable --now httpd
```

---

## **B. SELinux**

```bash
semanage fcontext -a -t httpd_sys_content_t "/srv/webdata(/.*)?"
restorecon -Rv /srv/webdata
```

Verify:

```bash
ls -Zd /srv/webdata
getenforce
```

---

## **C. ACLs**

```bash
useradd userA
useradd userB

setfacl -m u:userA:rwx /srv/webdata
setfacl -m u:userB:rx  /srv/webdata
```

Verify:

```bash
getfacl /srv/webdata
```

---

## **D. autofs**

Edit `/etc/auto.master`:

```
/misc   /etc/auto.web
```

Create `/etc/auto.web`:

```
webmount   -fstype=none,bind   :/srv/webdata
```

Enable autofs:

```bash
systemctl enable --now autofs
```

Test:

```bash
ls /misc/webmount
```

---

## **E. Firewalld**

```bash
firewall-cmd --permanent --add-service=http
firewall-cmd --reload
```
